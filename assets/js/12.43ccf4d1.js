(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{282:function(_,e,t){_.exports=t.p+"assets/img/vanish_point.40a28a45.png"},283:function(_,e,t){_.exports=t.p+"assets/img/distant_point.6dd3753e.png"},284:function(_,e,t){_.exports=t.p+"assets/img/preprocess.e459e73f.png"},285:function(_,e,t){_.exports=t.p+"assets/img/find_peaks.eb69ce3b.png"},286:function(_,e,t){_.exports=t.p+"assets/img/peaks.ab8e68ca.png"},287:function(_,e,t){_.exports=t.p+"assets/img/hough_lines_1.472f2f95.png"},288:function(_,e,t){_.exports=t.p+"assets/img/vanish_point_distance.20b6a7fe.png"},289:function(_,e,t){_.exports=t.p+"assets/img/diatant_point_links.c53ad05c.png"},290:function(_,e,t){_.exports=t.p+"assets/img/mid_cleanse_before.57d9f0d6.png"},291:function(_,e,t){_.exports=t.p+"assets/img/mid_cleanse_lines_with_circle.f23b4545.png"},292:function(_,e,t){_.exports=t.p+"assets/img/mid_cleanse_function.ef172eda.png"},293:function(_,e,t){_.exports=t.p+"assets/img/mid_cleanse_convert.385968c8.png"},294:function(_,e,t){_.exports=t.p+"assets/img/mid_cleanse_after-1584008112022.4ea4ee59.png"},295:function(_,e,t){_.exports=t.p+"assets/img/crop_basic.edc6b828.png"},296:function(_,e,t){_.exports=t.p+"assets/img/crop_scale.b188119b.png"},425:function(_,e,t){"use strict";t.r(e);var v=t(10),a=Object(v.a)({},(function(){var _=this,e=_._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[e("h1",{attrs:{id:"海图识别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#海图识别"}},[_._v("#")]),_._v(" 海图识别")]),_._v(" "),e("blockquote",[e("p",[_._v("本文的视频版，方便理解：")]),_._v(" "),e("p",[e("a",{attrs:{href:"https://www.bilibili.com/video/BV1Jg411Z7PL/",target:"_blank",rel:"noopener noreferrer"}},[_._v("[碧蓝航线]海图识别-从屏幕内容到海域信息(上)"),e("OutboundLink")],1)]),_._v(" "),e("p",[e("a",{attrs:{href:"https://www.bilibili.com/video/BV1it4y1E7pz/",target:"_blank",rel:"noopener noreferrer"}},[_._v("[碧蓝航线]海图识别-从屏幕内容到海域信息(下)"),e("OutboundLink")],1)])]),_._v(" "),e("p",[e("code",[_._v("海图识别")]),_._v(" 是一个碧蓝航线脚本的核心. 如果只是单纯地使用 "),e("code",[_._v("模板匹配 (Template matching)")]),_._v(" 来进行索敌, 就不可避免地会出现 BOSS被小怪堵住 的情况.  "),e("code",[_._v("AzurLaneAutoScript")]),_._v(" 提供了一个更好的海图识别方法, 在 "),e("code",[_._v("module.map")]),_._v(" 中, 你将可以得到完整的海域信息, 比如:")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("2020-03-10 22:09:03.830 | INFO |    A  B  C  D  E  F  G  H\n2020-03-10 22:09:03.830 | INFO | 1 -- ++ 2E -- -- -- -- --\n2020-03-10 22:09:03.830 | INFO | 2 -- ++ ++ MY -- -- 2E --\n2020-03-10 22:09:03.830 | INFO | 3 == -- FL -- -- -- 2E MY\n2020-03-10 22:09:03.830 | INFO | 4 -- == -- -- -- -- ++ ++\n2020-03-10 22:09:03.830 | INFO | 5 -- -- -- 2E -- 2E ++ ++\n")])])]),e("p",[_._v("module.map 主要由以下文件构成:")]),_._v(" "),e("ul",[e("li",[_._v("perspective.py 透视解析")]),_._v(" "),e("li",[_._v("grids.py 海域信息解析")]),_._v(" "),e("li",[_._v("camera.py 镜头移动")]),_._v(" "),e("li",[_._v("fleet.py 舰队移动")]),_._v(" "),e("li",[_._v("map.py 索敌逻辑")])]),_._v(" "),e("h2",{attrs:{id:"一点透视"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一点透视"}},[_._v("#")]),_._v(" 一点透视")]),_._v(" "),e("p",[_._v("在理解 "),e("code",[_._v("AzurLaneAutoScript")]),_._v(" 是如何进行海图识别之前, 需要快速了解一下 "),e("code",[_._v("一点透视")]),_._v(" 的基本原理. 碧蓝航线的海图是一个一点透视的网格, 解析海图的透视, 需要计算出灭点和距点.")]),_._v(" "),e("p",[_._v("在一点透视中:")]),_._v(" "),e("ul",[e("li",[_._v("所有的水平线的透视仍为水平线.")]),_._v(" "),e("li",[_._v("所有的垂直线相交于一点, 称为 "),e("code",[_._v("灭点")]),_._v(" . 灭点距离网格越远, 垂直线的透视越接近垂直.")])]),_._v(" "),e("p",[e("img",{attrs:{src:t(282),alt:"vanish_point"}})]),_._v(" "),e("ul",[e("li",[_._v("所有的对角线相交于一点, 称为 "),e("code",[_._v("距点")]),_._v(" . 距点离灭点越远, 网格越扁长. 距点和灭点在同一水平线上. 距点其实有两个, 它们关于灭点对称, 图中画出的是位于灭点左边的距点.")])]),_._v(" "),e("p",[e("img",{attrs:{src:t(283),alt:"distant_point"}})]),_._v(" "),e("h2",{attrs:{id:"截图预处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#截图预处理"}},[_._v("#")]),_._v(" 截图预处理")]),_._v(" "),e("p",[e("img",{attrs:{src:t(284),alt:"preprocess"}})]),_._v(" "),e("p",[_._v("拿到一张截图之后, "),e("code",[_._v("load_image")]),_._v(" 函数会进行以下处理")]),_._v(" "),e("ul",[e("li",[_._v("裁切出用于可以用于识别的区域.")]),_._v(" "),e("li",[_._v("去色, 这里使用了 "),e("code",[_._v("Photoshop")]),_._v(" 里的去色算法, (MAX(R, G, B) + MIN(R, G, B)) // 2")]),_._v(" "),e("li",[_._v("去UI, 这里使用 "),e("code",[_._v("overlay.png")]),_._v(" .")]),_._v(" "),e("li",[_._v("反相")])]),_._v(" "),e("p",[_._v("(上面的图是反相前的结果, 反相后的图过于恐怖, 就不放了)")]),_._v(" "),e("h2",{attrs:{id:"网格识别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网格识别"}},[_._v("#")]),_._v(" 网格识别")]),_._v(" "),e("h3",{attrs:{id:"网格线识别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网格线识别"}},[_._v("#")]),_._v(" 网格线识别")]),_._v(" "),e("p",[_._v("网格线, 是一条 20% 透明度的黑色线, 在 "),e("code",[_._v("720p")]),_._v(" 下, 有3至4像素粗. 在旧UI时, 只需要把图像上下左右移动一个像素, 再除以原图像, 便可以得到网格线. 新UI的海图格子增加了白色框, 白色框有透明度渐变, 增加了识别难度.")]),_._v(" "),e("p",[e("code",[_._v("find_peaks")]),_._v(" 函数使用了 "),e("code",[_._v("scipy.signal.find_peaks")]),_._v(" 来寻找网格线. "),e("code",[_._v("scipy.signal.find_peaks")]),_._v(" 可以寻找数据中的峰值点 : https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.find_peaks.html")]),_._v(" "),e("p",[_._v("截取 height == 370 处图像, 使用以下参数:")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("FIND_PEAKS_PARAMETERS = {\n    'height': (150, 255 - 40),\n    'width': 2,\n    'prominence': 10,\n    'distance': 35,\n}\n")])])]),e("p",[e("img",{attrs:{src:t(285),alt:"find_peaks"}})]),_._v(" "),e("p",[_._v("可以看出, 有一些被遮挡的没有识别出来, 还有很多识别错误, 不过问题不大.")]),_._v(" "),e("p",[_._v("然后扫描每一行, 绘制出图像. (出于性能优化, 实际中会把图像展平至一维再识别, 这将缩短时间消耗至约 1/4.)")]),_._v(" "),e("p",[e("img",{attrs:{src:t(286),alt:"peaks"}})]),_._v(" "),e("p",[_._v("至此, 我们得到了四幅图像, 分别对应 "),e("code",[_._v("垂直的网格内线")]),_._v(" "),e("code",[_._v("水平的网格内线")]),_._v(" "),e("code",[_._v("垂直的网格边线")]),_._v(" "),e("code",[_._v("水平的网格边线")]),_._v(" . 这一过程在 "),e("code",[_._v("I7-8700k")]),_._v(" 上需要花费约 0.13 s, 整个海图识别流程将花费约 0.15 s.")]),_._v(" "),e("p",[_._v("注意, 识别内线和边线所使用的参数是不一样的. 不同的地图, 应该使用对应的参数, 如果偷懒的话, 也可以使用默认参数, 默认参数是针对 "),e("code",[_._v("7-2")]),_._v(" 的, 可以在第七章中使用, 甚至可以用到 "),e("code",[_._v("北境序曲 D3")]),_._v(" .")]),_._v(" "),e("h2",{attrs:{id:"网格线拟合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网格线拟合"}},[_._v("#")]),_._v(" 网格线拟合")]),_._v(" "),e("p",[e("code",[_._v("hough_lines")]),_._v(" 函数使用了 "),e("code",[_._v("cv2.HoughLines")]),_._v(" 来识别直线, 可以得到四组直线.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(287),alt:"hough_lines_1"}})]),_._v(" "),e("p",[_._v("以 "),e("code",[_._v("垂直的网格内线")]),_._v(" 为例, 可以看到, 识别结果有一些歪的线.")]),_._v(" "),e("p",[_._v("我们在图片中间拉一条水平线, 称为 "),e("code",[_._v("MID_Y")]),_._v(" (如果要修正水平线, 就拉垂直线), 交于垂直线, 交点称为 "),e("code",[_._v("mid")]),_._v(" , 如果 "),e("code",[_._v("mid")]),_._v(" 之间的距离小于3, 就认为这些线是相近线, 并用他们的平均值代表他们. 这样就修正了结果.")]),_._v(" "),e("h2",{attrs:{id:"灭点拟合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#灭点拟合"}},[_._v("#")]),_._v(" 灭点拟合")]),_._v(" "),e("p",[_._v("我们知道, 在一点透视中所有垂直线相交于灭点, 但是网格识别的结果是有误差的, 不能直接求直线的交点.")]),_._v(" "),e("p",[e("code",[_._v("_vanish_point_value")]),_._v(" 函数用于计算, 某一点到所有垂直线的距离, 并用 "),e("code",[_._v("scipy.optimize.brute")]),_._v(" 暴力解出离直线组最近的点, 它就是 "),e("code",[_._v("灭点")]),_._v(" . 这个曲面描绘了点到垂直线的距离和. 为了在求解是能大胆抛弃距离较远的线, 在求距离是加了 "),e("code",[_._v("log")]),_._v(" 函数.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(288),alt:"vanish_point_distance"}})]),_._v(" "),e("p",[_._v("得到灭点后, 还记得之前的 "),e("code",[_._v("mid")]),_._v(" 吗, 将它们连接至灭点, 作为垂直线. 这是对结果的第二次修正.")]),_._v(" "),e("h2",{attrs:{id:"距点拟合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#距点拟合"}},[_._v("#")]),_._v(" 距点拟合")]),_._v(" "),e("p",[_._v("将最初得到的垂直线和水平线相交, 得到交点. 我们知道距点和灭点在同一水平线上, 在这条水平线上取点, 将所有交点连接至这点, 得到斜线, "),e("code",[_._v("_distant_point_value")]),_._v(" 函数将计算斜线的 "),e("code",[_._v("mid")]),_._v(" 之间的距离, 同样使用 "),e("code",[_._v("scipy.optimize.brute")]),_._v(" 暴力解出距离最小的点, 它就是  "),e("code",[_._v("距点")]),_._v(" .")]),_._v(" "),e("p",[_._v("如果将斜线绘制出来, 会有这样的图像, 虽然有很多错误的斜线, 但确实求出了正确的距点.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(289),alt:"diatant_point_links"}})]),_._v(" "),e("h2",{attrs:{id:"网格线清洗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网格线清洗"}},[_._v("#")]),_._v(" 网格线清洗")]),_._v(" "),e("p",[_._v("经过以上步骤, 我们得到了以下网格线, 大体正确, 但是有错误.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(290),alt:"mid_cleanse_before"}})]),_._v(" "),e("p",[_._v("取垂直线的 "),e("code",[_._v("mid")]),_._v(" ,")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[ 185.63733413  315.65944444  441.62998244  446.89313842  573.6301653\n  686.40881027  701.20376316  830.27394123  959.00511191 1087.91874026\n 1220.58809477]\n")])])]),e("p",[_._v("因为每个格子都是等宽的, 所以 "),e("code",[_._v("mid")]),_._v(" 理论上是一个等差数列, 但实际识别结果可能有错误的项, 也可能有缺失的项. 我们用一次函数表达这个关系 "),e("code",[_._v("y = a * x + b")]),_._v(". 由于错误和缺失, 这里的 "),e("code",[_._v("x")]),_._v(" 不一定是项数 "),e("code",[_._v("n")]),_._v(" ,  但只要没有10个以上的错误或者缺失, 就会有 "),e("code",[_._v("x ∈ [n - 10, n + 10]")]),_._v(" .")]),_._v(" "),e("p",[_._v("接下来, 把表达式改写为 "),e("code",[_._v("b = -x * a + y")]),_._v(" , 其中 "),e("code",[_._v("x ∈ [n - 10, n + 10]")]),_._v(" . 如果把"),e("code",[_._v("a")]),_._v("当作自变量, 把"),e("code",[_._v("b")]),_._v("当作因变量, 那么这是一组直线, 它有 11 * 21 条. 把它们描绘出来:")]),_._v(" "),e("p",[e("img",{attrs:{src:t(291),alt:"mid_cleanse_lines_with_circle"}})]),_._v(" "),e("p",[_._v("可以发现, 用橙色圈起来的地方有多条直线重合, 我们称为 "),e("code",[_._v("重合点")]),_._v(" ("),e("code",[_._v("coincident_point")]),_._v("). 那些错误的 "),e("code",[_._v("mid")]),_._v(" 产生的直线无法与其他直线交于重合点, 自然被剔除.")]),_._v(" "),e("p",[_._v("使用 "),e("code",[_._v("scipy.optimize.brute")]),_._v(" 暴力求解所有直线的最近点, 得到"),e("code",[_._v("重合点")]),_._v(" 的坐标")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("[-201.33197146  129.0958336]\n")])])]),e("p",[_._v("因此一次函数就是 "),e("code",[_._v("y = 129.0958336 * x - 201.33197146")]),_._v(" .")]),_._v(" "),e("blockquote",[e("p",[_._v("在计算点到直线的距离时, 使用了以下函数:")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("distance = 1 / (1 + np.exp(9 / distance) / distance)\n")])])]),e("p",[_._v("这个函数将削弱距离较远的直线的影响, 鼓励优化器选择局部最优解.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(292),alt:"mid_cleanse_function"}})])]),_._v(" "),e("blockquote",[e("p",[_._v("如何处理水平线?")]),_._v(" "),e("p",[_._v("过"),e("code",[_._v("距点")]),_._v("作任意一条直线, 与水平线相交. 将得到的交点与"),e("code",[_._v("灭点")]),_._v("连接, 就完成了水平线到垂直线的映射. 处理完再映射回水平线即可.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(293),alt:"mid_cleanse_convert"}})])]),_._v(" "),e("p",[_._v("最后, 以海图或者屏幕为边界生成 "),e("code",[_._v("mid")]),_._v(" , 此时缺失的 "),e("code",[_._v("mid")]),_._v(" 也得到了填充. 重新连接至灭点, 完成了垂直线的清洗.")]),_._v(" "),e("p",[_._v("绘制出网格识别的结果:")]),_._v(" "),e("p",[e("img",{attrs:{src:t(294),alt:"mid_cleanse_after"}})]),_._v(" "),e("h1",{attrs:{id:"网格裁切"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网格裁切"}},[_._v("#")]),_._v(" 网格裁切")]),_._v(" "),e("p",[_._v("事实上, 海域中的舰娘, 敌人, 问号等, 都是固定在网格中心的图片, 只不过这些图片会因为透视产生缩放而已. 注意, 仅仅是缩放, 图片不会因为透视产生变形, 产生变形的只有地面的红框和黄框.")]),_._v(" "),e("p",[e("img",{attrs:{src:t(295),alt:"crop_basic"}})]),_._v(" "),e("p",[e("code",[_._v("grid_predictor.py")]),_._v(" 中提供了 "),e("code",[_._v("get_relative_image")]),_._v(" 函数, 它可以根据透视, 裁切出关于网格中心相对位置的图片, 统一缩放到特定大小, 这样就可以愉快地使用模板匹配了.")]),_._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[_._v("from PIL import Image\nfrom module.config.config import cfg\ni = Image.open(file)\ngrids = Grids(i, cfg)\nout = Image.new('RGB', tuple((grids.shape + 1) * 105 - 5))\nfor loca, grid in grids.grids.items():\n    image = grid.get_relative_image(\n    \t(-0.415 - 0.7, -0.62 - 0.7, -0.415, -0.62), output_shape=(100, 100))\n    out.paste(image, tuple(np.array(loca) * 105))\nout\n")])])]),e("p",[e("img",{attrs:{src:t(296),alt:"crop_scale"}})]),_._v(" "),e("h2",{attrs:{id:"海域信息解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#海域信息解析"}},[_._v("#")]),_._v(" 海域信息解析")]),_._v(" "),e("p",[_._v("未完待续")])])}),[],!1,null,null,null);e.default=a.exports}}]);